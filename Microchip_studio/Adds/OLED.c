/*
 * OLED.c
 *
 * Sergio Isidoro - 1221709
 * Andre Nogueira - 1221709
 *
 * CHIP: Atmega328p 8MHz
 */

#include "OLED.h"

void oled_command(uint8_t cmd) {
	I2C_start();							// Inicia a comunicação I2C
	I2C_write(OLED_ADDRESS << 1);			// Envia o endereço do OLED no modo de escrita
	I2C_write(0x00);						// Indica que o próximo byte é um comando
	I2C_write(cmd);							// Envia o comando para o OLED
	I2C_stop();								// Encerra a comunicação I2C
}

void oled_data(uint8_t data) {
	I2C_start();							// Inicia a comunicação I2C
	I2C_write(OLED_ADDRESS << 1);			// Envia o endereço do OLED com o bit de escrita
	I2C_write(0x40);						// Indica que o próximo byte é um dado
	I2C_write(data);						// Envia o dado para o OLED
	I2C_stop();								// Encerra a comunicação I2C
}

void oled_clear(void) {						// Limpa a tela
	uint8_t page = 0;						// Inicializa o contador de paginas
	
	while (page < 8) {						// Loop enquanto page for menor que 8
		oled_command(0xB0 + page);			// Seleciona a pagina (0 a 7)
		oled_command(0x00);					// Endereco de coluna baixo
		oled_command(0x10);					// Endereco de coluna alto

		uint8_t col = 0;					// Inicializa o contador de colunas
		while (col < 130) {					// Loop enquanto col for menor que 130
			oled_data(0x00);				// Envia o byte 0x00 (todos os pixels apagados)
			col++;							// Incrementa o contador
		}
		
		page++;								// Incrementa o contador de p?ginas
	}
}

void oled_init(void) {						// Inicializacao do OLED
	oled_command(0xAE);						// Display OFF
	oled_command(0xD5); 					// Set clock divide ratio/oscillator frequency
	oled_command(0x80);
	oled_command(0xA8); 					// Set multiplex ratio
	oled_command(0x3F); 					// 1/64 duty
	oled_command(0xD3); 					// Set display offset
	oled_command(0x00);
	oled_command(0x40); 					// Set start line address
	oled_command(0x8D); 					// Charge pump setting
	oled_command(0x14); 					// Enable charge pump
	oled_command(0x20); 					// Memory addressing mode
	oled_command(0x00); 					// Horizontal addressing mode
	oled_command(0xA1); 					// Set segment re-map
	oled_command(0xC8); 					// COM output scan direction
	oled_command(0xDA); 					// Set COM pins hardware configuration
	oled_command(0x12);
	oled_command(0x81); 					// Set contrast control
	oled_command(0x7F);
	oled_command(0xD9); 					// Set pre-charge period
	oled_command(0xF1);
	oled_command(0xDB); 					// Set VCOMH deselect level
	oled_command(0x40);
	oled_command(0xA4); 					// Resume RAM content display
	oled_command(0xA6); 					// Normal display
	oled_clear();        					// Limpa a tela (preto)
	oled_command(0xAF); 					// Display ON
}

void oled_set_cursor(uint8_t row, uint8_t col) {	// Define o cursor (linha e coluna)
	oled_command(0xB0 + row);						// Define a pagina (linha)
	oled_command(0x00 + (col & 0x0F));				// Define a coluna baixa
	oled_command(0x10 + ((col >> 4) & 0x0F));		// Define a coluna alta
}

const uint8_t font5x7[][5] PROGMEM = {
	{0x00, 0x00, 0x00, 0x00, 0x00}, // Espaco (ASCII 32)
	{0x00, 0x00, 0x5F, 0x00, 0x00}, // ! (ASCII 33)
	{0x00, 0x07, 0x00, 0x07, 0x00}, // " (ASCII 34)
	{0x14, 0x7F, 0x14, 0x7F, 0x14}, // # (ASCII 35)
	{0x24, 0x2A, 0x7F, 0x2A, 0x12}, // $ (ASCII 36)
	{0x23, 0x13, 0x08, 0x64, 0x62}, // % (ASCII 37)
	{0x36, 0x49, 0x55, 0x22, 0x50}, // & (ASCII 38)
	{0x00, 0x05, 0x03, 0x00, 0x00}, // ' (ASCII 39)
	{0x00, 0x1C, 0x22, 0x41, 0x00}, // ( (ASCII 40)
	{0x00, 0x41, 0x22, 0x1C, 0x00}, // ) (ASCII 41)
	{0x14, 0x08, 0x3E, 0x08, 0x14}, // * (ASCII 42)
	{0x08, 0x08, 0x3E, 0x08, 0x08}, // + (ASCII 43)
	{0x00, 0x50, 0x30, 0x00, 0x00}, // , (ASCII 44)
	{0x08, 0x08, 0x08, 0x08, 0x08}, // - (ASCII 45)
	{0x00, 0x60, 0x60, 0x00, 0x00}, // . (ASCII 46)
	{0x20, 0x10, 0x08, 0x04, 0x02}, // / (ASCII 47)
	{0x3E, 0x51, 0x49, 0x45, 0x3E}, // 0 (ASCII 48)
	{0x00, 0x42, 0x7F, 0x40, 0x00}, // 1 (ASCII 49)
	{0x42, 0x61, 0x51, 0x49, 0x46}, // 2 (ASCII 50)
	{0x21, 0x41, 0x45, 0x4B, 0x31}, // 3 (ASCII 51)
	{0x18, 0x14, 0x12, 0x7F, 0x10}, // 4 (ASCII 52)
	{0x27, 0x45, 0x45, 0x45, 0x39}, // 5 (ASCII 53)
	{0x3C, 0x4A, 0x49, 0x49, 0x30}, // 6 (ASCII 54)
	{0x01, 0x71, 0x09, 0x05, 0x03}, // 7 (ASCII 55)
	{0x36, 0x49, 0x49, 0x49, 0x36}, // 8 (ASCII 56)
	{0x06, 0x49, 0x49, 0x29, 0x1E}, // 9 (ASCII 57)
	{0x00, 0x36, 0x36, 0x00, 0x00}, // : (ASCII 58)
	{0x00, 0x56, 0x36, 0x00, 0x00}, // ; (ASCII 59)
	{0x08, 0x14, 0x22, 0x41, 0x00}, // < (ASCII 60)
	{0x14, 0x14, 0x14, 0x14, 0x14}, // = (ASCII 61)
	{0x00, 0x41, 0x22, 0x14, 0x08}, // > (ASCII 62)
	{0x02, 0x01, 0x51, 0x09, 0x06}, // ? (ASCII 63)
	{0x32, 0x49, 0x79, 0x41, 0x3E}, // @ (ASCII 64)
	{0x7E, 0x11, 0x11, 0x11, 0x7E}, // A (ASCII 65)
	{0x7F, 0x49, 0x49, 0x49, 0x36}, // B (ASCII 66)
	{0x3E, 0x41, 0x41, 0x41, 0x22}, // C (ASCII 67)
	{0x7F, 0x41, 0x41, 0x41, 0x3E}, // D (ASCII 68)
	{0x7F, 0x49, 0x49, 0x49, 0x41}, // E (ASCII 69)
	{0x7F, 0x09, 0x09, 0x09, 0x01}, // F (ASCII 70)
	{0x3E, 0x41, 0x49, 0x49, 0x7A}, // G (ASCII 71)
	{0x7F, 0x08, 0x08, 0x08, 0x7F}, // H (ASCII 72)
	{0x00, 0x41, 0x7F, 0x41, 0x00}, // I (ASCII 73)
	{0x20, 0x40, 0x41, 0x3F, 0x01}, // J (ASCII 74)
	{0x7F, 0x08, 0x14, 0x22, 0x41}, // K (ASCII 75)
	{0x7F, 0x40, 0x40, 0x40, 0x40}, // L (ASCII 76)
	{0x7F, 0x02, 0x04, 0x02, 0x7F}, // M (ASCII 77)
	{0x7F, 0x04, 0x08, 0x10, 0x7F}, // N (ASCII 78)
	{0x3E, 0x41, 0x41, 0x41, 0x3E}, // O (ASCII 79)
	{0x7F, 0x09, 0x09, 0x09, 0x06}, // P (ASCII 80)
	{0x3E, 0x41, 0x51, 0x21, 0x5E}, // Q (ASCII 81)
	{0x7F, 0x09, 0x19, 0x29, 0x46}, // R (ASCII 82)
	{0x46, 0x49, 0x49, 0x49, 0x31}, // S (ASCII 83)
	{0x01, 0x01, 0x7F, 0x01, 0x01}, // T (ASCII 84)
	{0x3F, 0x40, 0x40, 0x40, 0x3F}, // U (ASCII 85)
	{0x1F, 0x20, 0x40, 0x20, 0x1F}, // V (ASCII 86)
	{0x7F, 0x20, 0x18, 0x20, 0x7F}, // W (ASCII 87)
	{0x63, 0x14, 0x08, 0x14, 0x63}, // X (ASCII 88)
	{0x03, 0x04, 0x78, 0x04, 0x03}, // Y (ASCII 89)
	{0x61, 0x51, 0x49, 0x45, 0x43}, // Z (ASCII 90)
	{0x00, 0x7F, 0x41, 0x41, 0x00}, // [ (ASCII 91)
	{0x02, 0x04, 0x08, 0x10, 0x20}, // \ (ASCII 92)
	{0x00, 0x41, 0x41, 0x7F, 0x00}, // ] (ASCII 93)
	{0x04, 0x02, 0x01, 0x02, 0x04}, // ^ (ASCII 94)
	{0x40, 0x40, 0x40, 0x40, 0x40}, // _ (ASCII 95)
	{0x00, 0x03, 0x07, 0x00, 0x00}, // ` (ASCII 96)
	{0x20, 0x54, 0x54, 0x54, 0x78}, // a (ASCII 97)
	{0x7F, 0x48, 0x44, 0x44, 0x38}, // b (ASCII 98)
	{0x38, 0x44, 0x44, 0x44, 0x20}, // c (ASCII 99)
	{0x38, 0x44, 0x44, 0x48, 0x7F}, // d (ASCII 100)
	{0x38, 0x54, 0x54, 0x54, 0x18}, // e (ASCII 101)
	{0x08, 0x7E, 0x09, 0x01, 0x02}, // f (ASCII 102)
	{0x0C, 0x52, 0x52, 0x52, 0x3E}, // g (ASCII 103)
	{0x7F, 0x08, 0x04, 0x04, 0x78}, // h (ASCII 104)
	{0x00, 0x44, 0x7D, 0x40, 0x00}, // i (ASCII 105)
	{0x20, 0x40, 0x44, 0x3D, 0x00}, // j (ASCII 106)
	{0x7F, 0x10, 0x28, 0x44, 0x00}, // k (ASCII 107)
	{0x00, 0x41, 0x7F, 0x40, 0x00}, // l (ASCII 108)
	{0x7C, 0x04, 0x18, 0x04, 0x78}, // m (ASCII 109)
	{0x7C, 0x08, 0x04, 0x04, 0x78}, // n (ASCII 110)
	{0x38, 0x44, 0x44, 0x44, 0x38}, // o (ASCII 111)
	{0x7C, 0x14, 0x14, 0x14, 0x08}, // p (ASCII 112)
	{0x08, 0x14, 0x14, 0x18, 0x7C}, // q (ASCII 113)
	{0x7C, 0x08, 0x04, 0x04, 0x08}, // r (ASCII 114)
	{0x48, 0x54, 0x54, 0x54, 0x20}, // s (ASCII 115)
	{0x04, 0x3F, 0x44, 0x40, 0x20}, // t (ASCII 116)
	{0x3C, 0x40, 0x40, 0x20, 0x7C}, // u (ASCII 117)
	{0x1C, 0x20, 0x40, 0x20, 0x1C}, // v (ASCII 118)
	{0x3C, 0x40, 0x30, 0x40, 0x3C}, // w (ASCII 119)
	{0x44, 0x28, 0x10, 0x28, 0x44}, // x (ASCII 120)
	{0x0C, 0x50, 0x50, 0x50, 0x3C}, // y (ASCII 121)
	{0x44, 0x64, 0x54, 0x4C, 0x44}, // z (ASCII 122)
	{0x00, 0x08, 0x36, 0x41, 0x00}, // { (ASCII 123)
	{0x00, 0x00, 0x7F, 0x00, 0x00}, // | (ASCII 124)
	{0x00, 0x41, 0x36, 0x08, 0x00}, // } (ASCII 125)
	{0x08, 0x08, 0x2A, 0x1C, 0x08}, // -> (ASCII 126)
	{0x08, 0x1C, 0x2A, 0x08, 0x08}, // <- (ASCII 127)
};

void oled_print(char* str) {
	uint8_t used_pixels = 0;

	while (*str) {
		
		if (*str >= 32 && *str <= 127) {							// Verifica se o caractere esta dentro da faixa permitida
			uint8_t i = 0;											// Inicializa o contador
			while (i < 5) {											// Loop enquanto i for menor que 5
				oled_data(pgm_read_byte(&font5x7[*str - 32][i]));	// Enviar byte da fonte
				i++;												// Incrementa o contador
			}
			oled_data(0x00);										// Espaco entre caracteres
			used_pixels += 6;										// Incrementa os pixels usados (5 para caractere + 1 para espa?o)
		} else {
			uint8_t i = 0;											// Inicializa o contador
			while (i < 5) {											// Loop enquanto i for menor que 5
				oled_data(0x00);									// Espaco vazio para caracteres fora da faixa
				i++;												// Incrementa o contador
			}
			oled_data(0x00);										// Espaco entre caracteres
			used_pixels += 6;
		}
		str++;														// Avanca para o proximo caractere
	}

	while (used_pixels < 128) {										// Supondo linha com 128 pixels de largura
		oled_data(0x00);											// Espaco vazio para limpar o restante da linha
		used_pixels++;
	}
}